
<div align=center><a href="https://myseoulguide.site"><img src="https://user-images.githubusercontent.com/74864925/130348752-6236918a-4553-4add-a6fd-b5928e20c062.png"/></a></div>

# <div align=center>Fall IN Asia</div> 
#### <div align=center>우리들만의 작은 여행 커뮤니티</div>

<br/>

<div align=center>
<img src="https://travis-ci.org/joemccann/dillinger.svg?branch=master"/>&nbsp;
  <img src="https://img.shields.io/github/stars/noah071610/Fall-IN-Asia?style=social"/>&nbsp;
  <img src="https://img.shields.io/github/watchers/noah071610/Fall-IN-Asia?style=social"/>&nbsp;
</div>

<br/>

<div align=center>
<img src="https://img.shields.io/badge/Photoshop-31A8FF?style=flat-square&logo=adobe-photoshop&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/HTML5-E34F26?style=flat-square&logo=HTML5&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/CSS3-1572B6?style=flat-square&logo=CSS3&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=flat-square&logo=JavaScript&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/TypeScript-3178C6?style=flat-square&logo=TypeScript&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/React-61DAFB?style=flat-square&logo=React&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Next.js-000000?style=flat-square&logo=Nextdotjs&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Redux_Toolkit-764ABC?style=flat-square&logo=Redux&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/SWR-000000?style=flat-square&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Emotion-DB7093?style=flat-square&logo=styled-components&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Tailwind_CSS-38B2AC?style=flat-square&logo=TailwindCSS&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Mapbox-000000?style=flat-square&logo=Mapbox&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Babel-F9DC3E?style=flat-square&logo=Babel&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Webpack-8DD6F9?style=flat-square&logo=Webpack&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Node.js-339933?style=flat-square&logo=node-dot-js&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/NestJS-E0234E?style=flat-square&logo=NestJS&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/TypeORM-F7A600?style=flat-square&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Swagger-85EA2D?style=flat-square&logo=Swagger&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Amazon_AWS-232F3E?style=flat-square&logo=Amazon-AWS&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Linux-FCC624?style=flat-square&logo=Linux&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/NGINX-009639?style=flat-square&logo=NGINX&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/PM2-2B037A?style=flat-square&logo=PM2&logoColor=white"/>&nbsp;
</div>

<br/>

<div align=center>
  <a href="https://github.com/noah071610" target="_blank"><img src="https://image.flaticon.com/icons/png/24/25/25657.png"/></a>&nbsp;
  <a href="https://www.instagram.com/salmonchobab" target="_blank"><img src="https://image.flaticon.com/icons/png/24/1409/1409946.png"/></a>&nbsp;
  <a href="mailto:noah071610@naver.com"><img src="https://image.flaticon.com/icons/png/24/552/552486.png"/></a>&nbsp;
  <a href="https://jshyunsoo.site/" target="_blank"><img src="https://image.flaticon.com/icons/png/24/3135/3135715.png"/></a>&nbsp;
</div>

<br/>

<div align=center>
  <a href="https://fallinasia.com"><img src="https://img.shields.io/badge/go_to_website-EFFDFF?style=for-the-badge"/>&nbsp;</a>
</div>

<br/><br/><br/><br/><br/>

## 🛺 Fall IN asia 소개
#### 우리들만의 작은 여행 커뮤니티.
<br/>

> 🎤 : 간단하게 Fall IN asia를 소개해주세요.

여행을 떠나는 사람 중 80% 이상은 여행 중 자기 생각과 경험을 공유하려고 합니다. 하지만 일반

블로그에서는 UI/UX적 요소와 기능 그리고 커뮤니티가 여행일지에 부적합합니다. 저는 이런

단점에 주목해 아시아 배낭여행자들을 위한 커뮤니티 웹사이트를 개발했습니다. 연대기라는

아이덴티티를 만들어 여행자들이 좀 더 쉽고 이펙트있게 여행일지를 작성하고 공유할 수 있도록

유도했고 낯선 현지에서도 한국인과 정보교류를 하며 타지를 함께 헤쳐 나갈 수 있도록

모멘트라는 편리한 정보교류 플랫폼도 제공합니다.

<br/><br/>

## 🛫 Fall IN asia 기본정보
<br/>

- 제작기간 : 2021/6 ~ 2021/8
- 개발자 : 장현수 (Noah) 외 0명
- 개발포지션 : 디자인 , 프론트엔드 , 백엔드 , 배포
- 반응형 웹 사이트

<br/><br/>

## 🚝 Fall IN asia 리뷰
#### 마이 서울 가이드의 기본적인 흐름에 대해서 리뷰해드리겠습니다.
<br/>

### 1. 메인페이지는 인기 여행지와 연대기, 모멘트 등으로 구성되어있습니다.
- 좋은 디자인의 웹사이트는 심지어 신뢰성까지 높인다는 분석에 인상깊어, 최대한 깔끔한 디자인으로 이용자를 잡기위해 노력했습니다.

<br/>
<div align=center>
  
![fallinasia_main](https://user-images.githubusercontent.com/74864925/130349185-ad01e0d0-5786-4e77-86bc-6a25f974c4fe.png)
![fallinasia_news_main](https://user-images.githubusercontent.com/74864925/130349229-7ca37190-871c-4b4b-a064-efd4f041b358.png)
![fallinasia_story_main](https://user-images.githubusercontent.com/74864925/130349226-c87f34e1-a869-417a-a081-a98369fab2bf.png)
  
</div>

<br/>

### 2. 모멘트페이지는 국가별로 나누어져있고 필터와 타입을 적용할 수 있습니다.
- 국가별 선택페이지에서 쉽게 국가선택이 가능하고 국가에 맞는 뉴스와 연대기를 표시합니다.

<br/>

<div align=center>

![fallinasia_country_select](https://user-images.githubusercontent.com/74864925/130349356-1e3004c1-8707-4927-a1c2-0e56a3e5ccb4.gif)
  
  </div>

<br/>

### 3. 연대기페이지에서 사용자는 자신의 여행일지를 작성하며 공유합니다.
- 위도와경도를 사용한 연대기맵, 게시물 목차 , 이전&다음페이지 (서버에서 작성자와 관련된 게시글을 우선으로 보내줌) , 코멘트기능 등을 구현했습니다.

<br/>

<div align=center>

![fallinasia_story_thumb](https://user-images.githubusercontent.com/74864925/130349410-0392ce16-795e-4880-9253-bd02a5ad9bf8.png)

![fallinasia_story_map](https://user-images.githubusercontent.com/74864925/130349412-e3a87df2-e1fd-4632-9c8d-27783eac3a20.png)

![fallinasia_story_article](https://user-images.githubusercontent.com/74864925/130349415-6e00b5d4-65d5-40ee-9f03-866004ba84ac.png)

![fallinasia_story_pagination](https://user-images.githubusercontent.com/74864925/130349419-771114a4-4db5-4291-a9bb-6a1bdaa7a48d.png)
  
  </div>

```javascript

📁story/[code]/[storyId]/index.tsx

  // aside 목차 구현
  useEffect(() => {
    // DOM에 직접 접근해 class를 지정합니다.
    // span에 class를 추가한 이유? : fixed헤더로 offset이 위로 올라가버려서 빈 span값에 absolute를 적용해 맞춰주었습니다.
    if (story) {
      let contentHeaders = document.querySelectorAll(".post-content > h1 , .post-content > h2");
      contentHeaders.forEach((v, i) => {
        const span = document.createElement("span");
        span.setAttribute("id", \`header_\${i + 1}\`);
        span.classList.add("anchor-offset-controller");
        v.classList.add("anchor-offset-parent");
        v.appendChild(span);
      });
    }
  }, [story]);

  ...

  
  📁PostAsideNav/index.tsx
  
  // aside 목차 구현
  useEffect(() => {
    if (postData) {
      // 정규식으로 헤더의 문자만 가져와 배열로 만듭니다.
      const headers =
        postData?.content
          ?.match(/<h1([^])*?.*?<\/h1>|<h2([^])*?.*?<\/h2>/g)
          ?.join(",")
          .split(",") || [];

      // state에 저장합니다. 이 배열값은 목차의 바로가기 기능에 사용됩니다.
      setHdClassList(Array.from({ length: headers.length }, (v, i) => "header_" + (i + 1)));
      setHeaders(headers);
    }
  }, [postData]);

  ...

  📁stories.service.ts

  // 이전,다음 페이지 구현
  // 작성자의 이전,다음 게시글를 우선적으로 가져옵니다.

  async getSidePosts(storyId: number, userId: number) {
    const prevPost = await this.StoriesRepository.findOne({
      select: ['thumbnail', 'title', 'code', 'id'],
      where: { user: userId, id: LessThan(storyId) },
    }).then((res) =>{ 
      if (!res) {
        // 만약 작성자의 게시글이 더 이상 없다면 유저 게시글이 아닌 이전 또는 다음게시글을 가져옵니다.
        return this.StoriesRepository.findOne({
          select: ['thumbnail', 'title', 'code', 'id'],
          where: { id: LessThan(storyId) },
        });
      } else {
        return res;
      }
    });

  ...

  📁Comment/index.tsx

  // Comment Like 기능
  const onClickLikeOrDisLike = useCallback(
    (value: string) => {
      if (!user) {
        toastErrorMessage("로그인이 필요합니다.");
        return;
      }
      axios
        .patch(\`/comment/\${value}/\${comment?.id}\`)
        .then(() => {
          if (value === "like") {
            toastSuccessMessage("댓글 좋아요!💓");
          } else {
            toastSuccessMessage("댓글 좋아요 취소💔");
          }
          // 좋아요 또는 좋아요취소가 정상적으로 수행되면 swr을 revalidate 해줍니다.
          revalidateComments();
          dispatch(getUserInfoAction());
        })
        .catch((error) => {
          toastErrorMessage(error);
          throw error;
        });
    },
    [user, comment]
  );

  ...

  // Comment를 클릭하면 subCommentForm이 열리고 답글을 작성 할 수 있습니다.
  {onSubCommentForm && (
    <SubCommentForm revalidateComments={revalidateComments} commentId={comment?.id} />
  )}
  // 답글이 3개이상 넘어가서 길어지면 자동으로 더보기 버튼이 나타납니다.
  {comment?.subComments?.length > 2 && (
    <div onClick={onChangeSubCommentList} className="more-subComment">
      <button className="more-subComment-btn">
        <span className="count">{comment?.subComments?.length}</span>
        개의 답글
        <DownCircleOutlined rotate={onSubCommentList ? 180 : 0} />
      </button>
    </div>
  )}
  // 답글이 있다면 답글을 뿌려줍니다.
  {onSubCommentList &&
    comment?.subComments?.map((v, i) => {
      return <SubComment key={i} revalidateComments={revalidateComments} subComment={v} />;
    })}
  
 ```

<br/>

### 4. 유저페이지에서 자신이 여행했던 국가의 루트맵 그리고 국가리스트를 볼 수 있습니다.
- 게시글 & 답글 알림시스템 , 여행했던 국가리스트 맵 및 overview , 작성 게시물 전체보기를 구현했습니다.

<br/>

<div align=center>

![fallinasia_user_map](https://user-images.githubusercontent.com/74864925/130349463-abe5f706-96d0-4315-9e29-9fde7f2b5c39.gif)
  
  </div>

```javascript

📁CountryRouteMap.tsx

  const CountryRouteMap: FC<IProps> = ({ stories }) => {
    const mapRef = useRef<MapRef>(null);
    const [viewport, setViewport] = useState({
      width: "100%",
      height: 350,
      // 혹시 값이 없으면 대한민국의 정중앙을 좌표로 삼습니다.
      latitude: stories?.[0]?.lat || 37.50529626491968,
      longitude: stories?.[0]?.lng || 126.98047832475031,
      zoom: 1,
    });

    const route = useMemo(() => {
      return {
        type: "Feature",
        properties: {},
        geometry: {
          type: "LineString",
          //story 엔티티의 칼럼에는 좌표가 있습니다. 이값을 2중배열으로 뿌려줍니다.
          coordinates: stories?.map((v) => [v.lng, v.lat]),
        },
      };
    }, [stories]);

    const handleViewportChange = useCallback(
      // 좌표가 변하면 그 값을 저장합니다. 넓이는 고정으로 100%를 유지하기위해 스프레드연산자와 같이 활용했습니다.
      (newViewport) => setViewport({ ...newViewport, width: "100%" }),
      []
    );

    return (
      <ReactMapGL
        className="map-gl"
        ref={mapRef}
        {...viewport}
        mapboxApiAccessToken={process.env.NEXT_PUBLIC_MAPBOX_API_KEY}
        onViewportChange={handleViewportChange}
        mapStyle="mapbox://sprites/mapbox/basic-v8"
        asyncRender={true}
        transitionInterpolator={new FlyToInterpolator()}
      >
        <Source type="geojson" data={route as any}>
          <Layer
            id="route"
            type="line"
            source="route"
            layout={{ "line-join": "round", "line-cap": "round" }}
            paint={{ "line-color": "red", "line-width": 2 }}
          />
        </Source>
        {/* 좌표값에 맞게 마커를 뿌려줍니다. */}
        {stories?.map((v, i) => (
          <Marker
            key={i}
            longitude={v.lng}
            latitude={v.lat}
            offsetTop={-20}
            offsetLeft={-10}
            draggable={false}
          >
            <Pin isUserInfoPage={true} story={v} size={20} />
          </Marker>
        ))}
      </ReactMapGL>
    );
  };

  export default memo(CountryRouteMap);

  ...

  📁VisitedCountryList.tsx

  const VisitedCountryList: FC<IProps> = ({ stories }) => {
    
    // 값을 캐싱하기 위해 useMemo를 사용합니다.

    const storiesWithoutSame = useMemo(() => {

      // 다녀온 국가 리스트에서 중복을 제거해 반환합니다.
      // filter로 배열을 순회합니다 중복된 값(국가)가 나오면 findIndex의 값과 filter의 i 값이 일치하지 않게되어 걸러집니다.
      // code는 국가코드입니다 (예 : KR JP TH)

      return stories?.filter((v, i, arr) => i === arr.findIndex((t) => v.code === t.code));
    }, [stories]);
  
    return (
      <VisitedCountryListWrapper>
        {storiesWithoutSame?.map((v, i) => (
          <li key={i}>
            <div className="image-wrapper">
              <img src={v.country.flag_src} alt="flag_image" />
            </div>
            <span>{v.country.name}</span>
          </li>
        ))}
      </VisitedCountryListWrapper>
    );
  };
  
  export default memo(VisitedCountryList);
 
 ```

<br/>

### 5. 유저페이지에서 자기소개, 아이콘, 비밀번호 변경 및 회원탈퇴 그리고 팔로우와 언팔로우가 가능합니다.
- 아이콘은 crop을 사용해 원하는 사이즈로 잘라서 변경 가능하며 팔로우 기능은 DB의 다대다 관계 테이블을 사용했습니다.

<br/>

<div align=center>

![fallinasia_user_crop](https://user-images.githubusercontent.com/74864925/130349485-b07e35c9-ff4e-4e17-96aa-2e87146681ca.gif)
  
  </div>

```javascript

📁IconCropperModal/index.tsx

  ...
  
  return (

      ...

    {upImg ? (
      {/* upImg가 있다면 크롭창을 띄워줍니다 이미지를 정사각형크기로 잘라 수정할 수 있습니다. */}
      <div className="crop-image-wrapper">
        <ReactCrop
          className="crop-image"
          src={upImg as string}
          onImageLoaded={onLoad}
          crop={crop}
          onChange={(c) => setCrop(c)}
          onComplete={(c) => setCompletedCrop(c)}
        />
      </div>
    ) : (
      {/* upImg가 없다면 업로드창을 표시합니다. drag해서 편리하게 업로드 가능합니다. */}
      <Dragger
        showUploadList={false}
        multiple={false}
        className="dragger"
        onChange={handleChange}
      >
        <div className="dragger-inside-image">
          <img
            src="https://user-images.githubusercontent.com/74864925/124657825-f38a5500-dedd-11eb-8de9-6ed70a512f24.png"
            alt="drag"
          />
          <p>이미지 드래그 또는 선택</p>
        </div>
      </Dragger>
    )}
    {upImg && (
      {/* 크롭이미지가 실제 아이콘에 어떻게 표시될지 미리 볼 수 있습니다. */}
      <div className="image-preview">
        <NameSpaceWrapper className="name-space-preview">
          <div className="icon">
            <canvas className="cropped-image" ref={previewCanvasRef} />
          </div>
          <div className="user-info">
            <span className="name">{user?.name}</span>
            <span className="date">2021/07/29</span>
          </div>
        </NameSpaceWrapper>
        <div className="btn-wrapper">
          <button onClick={() => setUpImg(null)}>다시 선택</button>
          <button className="btn-point" onClick={onClickChangeIcon}>
            이미지 올리기
          </button>
        </div>
      </div>
    )}
  )
  
  ...

  📁UserInfoAside/index.tsx

  ...

  <h3>팔로워</h3>
  {userInfo && (
    <div className="follow-wrapper">
      <div className="follow-icon-wrapper">
        {/* 최대 6명의 팔로워 아이콘을 표시해줍니다. */}
        {userInfo?.followers.slice(0, 6).map((v, i) => (
          <img key={i} src={v.follower.icon} alt="follow-icon" />
        ))}
      </div>
      <span>
        {/* user에 follow 테이블을 조인해 가져와 뿌려줍니다. */}
        {userInfo.followers.length > 0
          ? \`\${userInfo?.followers[0].follower?.name}님 외 \${
              userInfo?.followers?.length - 1
            }명 팔로우.\`
          : "아직 팔로워가 없습니다."}
      </span>
    </div>
  )}
  <h3>팔로잉</h3>
  {/* 팔로워와 같은 맥락으로 작성 */}
  
  ...

  📁Follow.ts

  // @ManyToMany()를 사용하지 않은 이유? : nestJS에서 ManyToMany관련 이슈가 많아서 
  // 안정성을 고려해 사용하지않고 Follow테이블에 1대다관계로 묶어줬습니다 (같은 기능을 수작업으로 구현한 느낌)

  @IsNotEmpty()
  @ApiProperty({
    example: 1,
    description: 'followingId (Following)',
  })
  @Column()
  followingId: number;

  @IsNotEmpty()
  @ApiProperty({
    example: 1,
    description: 'followerId (Follower)',
  })
  @Column()
  followerId: number;

  @ManyToOne(() => Users, (users) => users.followings, {
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE',
  })
  @JoinColumn({ name: 'followingId' })
  following: Users;

  @ManyToOne(() => Users, (users) => users.followers, {
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE',
  })
  @JoinColumn({ name: 'followerId' })
  follower: Users;

  ...

```

<br/>

### 6. 반응형을 지원합니다.
- 모바일에서도 이용자가 불편하지 않도록 반응형으로 개발했습니다.

<br/>

<div align=center>

![fallinasia_main_mobile](https://user-images.githubusercontent.com/74864925/130349515-f4596e82-b927-4853-acdc-2b8a643958e1.gif)

![fallinasia_story_mobile](https://user-images.githubusercontent.com/74864925/130349517-ad87d49d-1b91-4c7a-baff-79eddcd21ec5.gif)
  
  </div>

<br/>

### 7. IntersectionObserver 를 이용해 최적성능의 infinite scroll을 구현했습니다.
- 이전 프로젝트(Noahworld)에서 scroll event로만 사용해 구현했을때보다 성능이 향상됬습니다. 또 피치못하게 scroll event를 이용시 throttle을 적용합니다.

<br/>

<div align=center>

![fallinasia_infinite](https://user-images.githubusercontent.com/74864925/130349543-a89b7c2b-a4b4-4ad8-8b09-138f62415e94.gif)
  
  </div>

```javascript

📁index.tsx

  // swr과 observer를 이용해 infinite 스크롤을 구현합니다.

  const { query } = useRouter();
  const [filter, setFilter] = useState("");
  const {
    data: moments,
    revalidate: revalidateMoments,
    setSize,
  } = useSWRInfinite<IMoment[]>(
    (index) => \`/moment?page=\${index + 1}&filter=\${filter}&type=\${query?.type || ""}\`,
    fetcher,
    {
      // SSR로 서버에서 렌더된 initial Data를 넣어줍니다
      initialData: initialMoments,
      ...noRevalidate,
    }
  );

  ...

  📁hooks/useOnScreen.ts

  const useOnScreen = (ref: RefObject<HTMLDivElement>) => {
    const [isIntersecting, setIntersecting] = useState(false);
  
    useEffect(() => {
      // observer를 생성합니다.
      const observer = new IntersectionObserver(([entry]) => setIntersecting(entry.isIntersecting));
  
      // MomentList의 ref를 넣어줍니다.
      if (ref?.current !== null) {
        //ref는 최초 null값이고 렌더링시 dom을 잡아옵니다.
        //이에 알맞게 if문을 넣어줬습니다.
        observer.observe(ref.current);
      }
      return () => {
        // 메모리 낭비를 방지하기 위해 unmount시 연결을 끊어줍니다.
        observer.disconnect();
      };
    }, []);
  
    return isIntersecting;
  };

  export default useOnScreen;


  📁MomentList/index.tsx

  interface IProps {
    moments: IMoment[][] | undefined;
    setSize: (f: (size: number) => number) => Promise<IMoment[][] | undefined>;
    setFilter: (filter: string) => void;
    filter: string;
    revalidateMoments: () => void;
  }

  const MomentList: FC<IProps> = ({ revalidateMoments, filter, moments, setSize, setFilter }) => {
    const [isReachingEnd, setIsReachingEnd] = useState(true);
    const ref = useRef<HTMLDivElement>(null);
    const isVisible = useOnScreen(ref);
    const isEmpty = moments?.[0]?.length === 0;

    useEffect(() => {
      if (moments) {
        // 이중배열의 마지막값의 길이가 10개가 아닌지 확인합니다.
        // 서버에서 10개씩 데이터를 가지고 옴으로 10개 미만이면 끝에 도달했다고 판단하고 false로 설정합니다.
        setIsReachingEnd(moments[moments.length - 1]?.length < 10);
      }
    }, [moments]);
    useEffect(() => {
      // data가 아직 남아있으면 size 값을 1씩 증가시켜 데이터를 가져옵니다.
      if (isVisible && !isReachingEnd && !isEmpty) {
        setSize((prev) => prev + 1).then(() => {});
      }
    }, [isVisible]);

    // swr가 이중배열을 가져오기 때문에 flat 메쏘드를 사용해서 1차원배열로 만들어줍니다.
    const momentsData = moments ? moments?.flat() : [];

    return (
      <MomentListWrapper>
        <div className="content-wrapper">
          <div className="content-filter">
            {/* 필터를 누르면 query에 넣어져 그에 맞는 데이터를 다시 가져옵니다. */}
            <button
              style={filter === "" ? { fontWeight: "bold", color: BLUE_COLOR } : {}}
              onClick={() => setFilter("")}
            >
              최신순
            </button>
            
            ...

          </div>
          {/* 데이터를 뿌려줍니다. */}
          {momentsData.length > 0 ? (
            momentsData?.map((v, i) => {
              if (momentsData.length - 1 === i) {
                {/* 마지막데이터는 UI 요소를 다르게 해야하기때문에 따로 isLast props를 넣어줍니다. */}
                return (
                  <MomentCard
                    revalidateMoments={revalidateMoments}
                    isLast={true}
                    key={i}
                    moment={v}
                  />
                );
              }
              return <MomentCard revalidateMoments={revalidateMoments} key={i} moment={v} />;
            })
          
            ...

          {/* ref를 마지막 부분에 담아줍니다 observer에 이 div가 보이면 데이터를 더 불러옵니다. */}
          <div ref={ref} />
        </div>
      </MomentListWrapper>
    );
  };

  // props가 변하지 않는 한 리렌더링을 막기 위해 React memo를 넣어줍니다.
  export default memo(MomentList);

  📁moments.service.ts

  async getPosts(code?: string, page?: number, type?: string) {

    // typeORM의 쿼리빌더를 사용해 값을 10개씩 가져옵니다.
    // 필요없는 데이터를 가지고오지않도록 leftJoin 후 addSelect 해주었습니다.

    const posts = await this.MomentsRepository.createQueryBuilder('moments')
      .where(code ? \`moments.code = :code\` : '1=1', { code })
      .andWhere(type ? \`moments.type = :type\` : '1=1', { type })
      .addSelect([
        'country.name',
        'user.id',
        'user.icon',
        'user.name',
        'likedUser.id',
        'comments.id',
      ])
      .leftJoin('moments.country', 'country')
      .leftJoin('moments.user', 'user')
      .leftJoin('moments.likedUser', 'likedUser')
      .leftJoin('moments.comments', 'comments')
      .leftJoinAndSelect('moments.images', 'images')
      .orderBy('moments.id', 'DESC')
      .skip((page - 1) * 10)
      .take(10)
      .getMany();

    if (!posts) {
      throw new NotFoundException('모멘트를 찾을 수 없습니다.');
    }
    return posts;
  }
  
  ```

<br/>

### 8. Auth에 대한 많은 기능등을 구현했습니다.
- 회원가입 / nodemailer를 이용한 이메일 인증 / PassportJS와 세션,쿠키를 이용한 소셜 로그인 및 로그인 유지 / bcrypt를 사용한 비밀번호 암호화 / 회원정보변경 / 회원탈퇴 등을 구현했습니다.!

<br/>

<div align=center>

![fallinasia_signup](https://user-images.githubusercontent.com/74864925/130349569-9fe8143b-2e5a-4f65-863f-9528672f1ea1.png)
  
  </div>

```javascript

📁SignupModal/index.tsx & 📁LoginModal/index.tsx

  const onClickSendEmailAuth = useCallback(
    (e) => {
      e.preventDefault();
      if (!email || !email?.trim()) {
        toastErrorMessage("이메일을 입력해주세요.");
        return;
      }

      // 정규식을 사용해 이메일의 형식도 꼼꼼히 따져줍니다.

      if (!email.match(/[A-Za-z0-9_\.\-]+@[A-Za-z0-9\-]+\.[A-Za-z0-9\-]+/)) {
        toastErrorMessage("이메일을 형식을 올바르게 작성해주세요.");
        return;
      }
      axios
        .post("/auth/email", { email })
        .then(() => {
          setOnEmailCheckForm(true);
          toastSuccessMessage(\`\${email}로 이메일이 발송되었습니다. 인증번호를 확인해주세요.\`);
        })
        .catch((error) => {
          toastErrorMessage(error);
          throw error;
        });
    },
    [email]
  );

  ...

  //회원가입시 사용자 입력값을 예외처리로 꼼꼼하게 따져줍니다.
  
  const onFinishSignUp = useCallback((values: any) => {
    if (!values.email || !values.email?.trim()) {
      toastErrorMessage("이메일을 입력해주세요.");
      return;
    }
    if (!values.authNum || !values.authNum?.trim()) {
      toastErrorMessage("이메일 인증번호가 필요합니다.");
      return;
    }
    if (!values.password || !values.password?.trim()) {
      toastErrorMessage("비밀번호를 입력해주세요.");
      return;
    }
    let name = values?.first_name + values?.last_name;
    if (!name || !name?.trim()) {
      toastErrorMessage("이름을 입력해주세요.");
      return;
    }
    let form: IUserRequestForm = {
      email: values.email,
      name,
      password: values.password,
      authNum: values.authNum,
    };
    dispatch(signupAction(form));
  }, []);

  ...

  // 소셜 로그인 구현

  <a
    href={
      process.env.NODE_ENV === "development"
        ? "http://localhost:3060/api"
        : process.env.NEXT_PUBLIC_BASE_URL + "/auth/google"
    }
  >
    <img src="https://img.icons8.com/color/144/000000/google-logo.png" />
  </a>


  // 이메일 인증

  📁auth.controller.ts
  
  @UseGuards(new NotLoggedInGuard())
  @ApiOperation({ summary: 'send auth number for signup' })
  @Post(\`email\`)
  async sendEmailAuthNumber(@Body() data) {
    const authNum = await this.AuthService.checkPossibleEmail(data.email);
    this.MailerService.sendMail({
      to: data.email,
      from: process.env.EMAIL_ID,
      subject: 'Fall IN Asia 이메일 인증 요청 메일입니다.',
      html: \`<p>안녕하세요. Fall IN Asia 입니다. 인증번호를 보내드립니다. 인증번호를 입력하고 회원가입을 진행해주세요</p><br/><p>인증번호 : <b>\${authNum}</b></p>\`,
    });
    return true;
  }

  📁auth.service.ts

  // 로그인 기능

  ...

  async validateUser(email: string, password: string) {
    const user = await this.UserRepository.findOne({
      where: { email },
      select: ['id', 'icon', 'email', 'password'],
    });
    if (!user) {
      throw new UnauthorizedException('유효하지 않은 이메일입니다.');
    }
    const result = await bcrypt.compare(password, user.password);
    if (result) {
      const { password, ...userWithoutPassword } = user;
      return userWithoutPassword;
    } else {
      throw new UnauthorizedException('비밀번호가 틀렸습니다.');
    }
  }

  ...

  📁local.strategy.ts

  // passport local strategy (이외 구글,카카오,네이버 strategy도 구현 )

  @Injectable()
  export class LocalStrategy extends PassportStrategy(Strategy) {
    constructor(private authService: AuthService) {
      super({ usernameField: 'email', passwordField: 'password' });
    }

    async validate(email: string, password: string, done: CallableFunction) {
      const user = await this.authService.validateUser(email, password);
      if (!user) {
        throw new UnauthorizedException(
          '이메일주소가 일치하지 않습니다. 다시한번 확인해주세요.',
        );
      }
      return done(null, user);
    }
  }
  
 ```

<br/>


### 9. SEO 최적화를 위해 노력했습니다.
- 메타태그를 세심하고 효율적이게 작성하며 (title , description ...) 시맨틱마크업 준수와 헤더태그를 적절히 사용해 최적화했습니다.

<br/>

```javascript

  📁pages/country/[code]/[id]

  ...

  // 문득보면 Next의 Head태그가 번거로워 보이지만 SEO에 있어서 메타태그는 중요하기 때문에 최대한 깊고 세세하게 작성했습니다.

  <Head>
    <title>
      {html2textConverter(moment?.content).slice(0, 20)}... - {moment?.country?.name}/
      {moment?.id}번모멘트 | Fall IN Asia
    </title>
    <meta name="description" content={html2textConverter(moment?.content).slice(0, 100)} />
    <meta
      property="og:title"
      content={\`\${html2textConverter(moment?.content).slice(0, 20)}... - \${
        moment?.country?.name
      }/
      \${moment?.id}번모멘트 | Fall IN Asia\`}
    />
    <meta
      property="og:description"
      content={html2textConverter(moment?.content).slice(0, 100)}
    />
    <meta
      property="og:image"
      content={moment?.images.length! > 0 ? moment?.images[0].image_src : WORLD_IMAGE}
    />
    <meta
      property="og:url"
      content={\`https://fallinasia.com/country/\${moment?.code}/\${moment?.id}\`}
    />
  </Head>

  ...
  
```

<br/>

### 10. 필요에따라 모듈을 직접 구현하여 프로젝트에 자체적으로 사용했습니다.
- Dayjs를 이용한 날짜계산 formatter , KMBT formatter (17.3K , 2M 같은 형식), Html to Text Converter 등을 직접 구현했습니다.

<br/>

```javascript

📁utils/dateCalculator.ts

  import dayjs from "dayjs";
  import relativeTime from "dayjs/plugin/relativeTime";
  import "dayjs/locale/ko";

  dayjs.locale("ko");
  dayjs.extend(relativeTime);

  export default function dateCalculator(createdAt: Date) {
    const createdDay = dayjs(createdAt).format("YYYY-MM-DD");
    const today = dayjs(new Date()).format("YYYY-MM-DD");
    const dayDiff = dayjs(today).diff(createdDay, "day");
    if (dayDiff > 0) {
      return createdDay;
    } else {
      return dayjs(createdAt).fromNow();
    }
  }


  📁utils/kmbtFormatter.ts

  const number_formatter = (unit: string, abs_views: number) => {
    let measure_unit = 0;
    switch (unit) {
      
      // 거듭제곱을 사용한 이유는 가독성을 위해서 입니다 100000000 이렇게 쓰면 눈아프고 유지보수가 힘들어집니다.

      case "k":
        measure_unit = 10 ** 3;
        break;
      case "m":
        measure_unit = 10 ** 6;
        break;
      case "b":
        measure_unit = 10 ** 9;
        break;
      case "t":
        measure_unit = 10 ** 12;
        break;
      default:
        return;
    }
    const views_split = String(abs_views / measure_unit).split(".");
    if (views_split.length === 1) {
      return views_split[0] + unit;
    } else {
      const decimal = views_split[1].slice(0, 1);
      if (decimal === "0") {
        return views_split[0] + unit;
      } else {
        return views_split[0] + "." + decimal + unit;
      }
    }
  };


  export function kmtb_Formatter(views: number) {
    if (!views) {
      return 0;
    }
    let abs_views = Math.abs(views);
    if (abs_views < 999) {
      return abs_views;
    }
    if (999 <= abs_views && abs_views <= parseInt("9".repeat(6))) {
      return number_formatter("k", abs_views);
    }

    // repeat를 사용한 이유는 가독성을 위해서 입니다 999999999 이렇게 쓰면 눈아프고 유지보수가 힘들어집니다.

    if (parseInt("9".repeat(6)) < abs_views && abs_views <= parseInt("9".repeat(9))) {
      return number_formatter("m", abs_views);
    }
    if (parseInt("9".repeat(9)) < abs_views && abs_views <= parseInt("9".repeat(12))) {
      return number_formatter("b", abs_views);
    }
    if (parseInt("9".repeat(12)) < abs_views) {
      return number_formatter("t", abs_views);
    }
  }
  

  📁utils/html2textConverter.ts

  export default function html2textConverter(content?: string): string {
    return content?.replace(/(<([^>]+)>)/gi, "").replace(/&nbsp;|&amp;/gi, "") || "";
  }

```

<br/>

### 11. 자주사용하는 컴포넌트는 따로 분리하여 재사용성을 향상시켰습니다.
- component / layout / section / pages 등으로 체계적이게 분리해 개발했습니다. 예시로 네, 아니오로 구성된 confirm 메세지같은 경우에는 많은곳에서 사용되기 때문에 개별적인 컴포넌트로 분리해, 알맞는 props를 그때그때 넣어주는 방식으로 만들었습니다.

<br/>

```javascript

📁ConfirmToastify.tsx

  import { toast } from "react-toastify";

  const ConfirmToastForm = ({
    onClickConfirm,
    closeToast,
    message,
    type,
  }: {
    onClickConfirm: () => void;
    closeToast?: any;
    message: string;
    type: string;
  }) => (
    <div style={{ cursor: "default" }}>
      <h4 style={{ marginLeft: "0.3rem" }}>{message}</h4>
      <div className="confirm-btn-wrapper">
        <button
          onClick={() => {
            onClickConfirm();
            closeToast();
          }}
        >
          네 {type}
        </button>
        <button onClick={closeToast}>아니요</button>
      </div>
    </div>
  );
  
  export const toastConfirmMessage = (onClickConfirm: () => void, message: string, type: string) => {
    toast(<ConfirmToastForm onClickConfirm={onClickConfirm} message={message} type={type} />, {
      position: "top-center",
      hideProgressBar: true,
      closeOnClick: false,
      pauseOnHover: true,
      draggable: true,
      progress: undefined,
    });
  };
  
 ```

<br/>

### 12. 코드의 가독성을 최대한 고려하며 중복방지를 위해 힘썼습니다.
- 보여드리는 코드는 중복 최소화 작업을 진행한 코드의 예시입니다. 중복제거도 좋지만 그것이 가독성이 떨어지는 요인이 된다면 중복 최소화 작업을 일단 고려하거나 보류합니다.

<br/>

```javascript

📁UserInfoAside/index.tsx

  // 함수들이 "클릭하면 유저의 정보를 변경한다 다만 본인이 아니면 반려한다" 는 맥락이 같습니다.
  // 가독성을 유지하며 중복을 최소화하기 위해 코드를 변경하겠습니다.
  
  const onClickConfirmRemoveIcon = useCallback(() => {
    if (!isOwner) {
      toastErrorMessage("본인프로필만 변경 가능합니다.");
      return;
    }
    dispatch(deleteUserIconAction());
  }, [isOwner]);

  const onClickChangeUserInfo = useCallback(() => {
    if (!isOwner) {
      toastErrorMessage("본인프로필만 변경 가능합니다.");
      return;
    }
    dispatch(changeUserInfoAction({ userName, introduce }));
    setUserInfoEdit(false);
  }, [userName, introduce, isOwner]);

  const onClickChangePassword = useCallback(() => {
    if (!isOwner) {
      toastErrorMessage("본인프로필만 변경 가능합니다.");
      return;
    }
    dispatch(changeUserPasswordAction({ prevPassword, newPassword }));
  }, [prevPassword, newPassword, isOwner]);

  const onClickWithdrawal = useCallback(() => {
    if (!isOwner) {
      toastErrorMessage("본인프로필만 변경 가능합니다.");
      return;
    }
    dispatch(mainSlice.actions.toggleWithdrawalModal());
  }, [isOwner]);




  //
  // 👊 중복최소화를 위해 코드를 이렇게 변경했습니다.
  //

  const onClickUserSetting = useCallback(
    (type: string) => {
      if (!isOwner) {
        toastErrorMessage("본인프로필만 변경 가능합니다.");
        return;
      }
      switch (type) {
        case "remove_icon":
          dispatch(deleteUserIconAction());
          break;
        case "user_info":
          dispatch(changeUserInfoAction({ userName, introduce }));
          setUserInfoEdit(false);
          break;
        case "password":
          dispatch(changeUserPasswordAction({ prevPassword, newPassword }));
          break;
        case "withdrawal":
          dispatch(mainSlice.actions.toggleWithdrawalModal());
          break;
        default:
          return;
      }
    },
    [isOwner, userName, introduce, prevPassword, newPassword]
  );
 
 ```

<br/>

### 13. CSS styling을 체계적으로 작성하고 custom CSS를 사용해 가능한 한 중복을 줄이고 능률을 높였습니다.
- 개별적으로 styles.tsx 파일을 두며 tailwindCSS 와 emotion을 적용했습니다. ellipsis처리와 flex 스타일등은 라이브러리로도 반복된 작업이 많아 custom CSS로 만들어 해결했습니다.

<br/>

```javascript

📁Header/styles.tsx

  export const HeaderWrapper = (headerDownSize: boolean) => css\`

    \${tw\`w-full bg-white fixed\`}
    \${headerDownSize ? tw\`py-2 px-4\` : tw\`py-4 px-8\`}
    z-index:60;
    transition: 0.3s all;
    \${BORDER_THIN("border-bottom")};
    \${FLEX_STYLE("space-between", "center")};

    .header-logo {
      \${tw\`w-40 h-8 mr-6\`}
      transition: 0.3s all;
      \${headerDownSize && \`transform:scale(0.8);\`}
      img {
        \${tw\`w-full h-full\`}
      }
    }
    .header-list {
      transition: 0.3s all;
      \${tw\`ml-3 relative\`}
      padding: 0.3rem 0.5rem;
      &-anchor {
        transition: 0.3s all;
        \${tw\`font-bold\`}
        \${headerDownSize ? tw\`text-sm\` : "font-size:1.05rem"}
      }
    }

    .notice-icon,
    .search-icon,
    .menu-icon {
      \${headerDownSize ? tw\`text-base\` : tw\`text-2xl\`}
    }
    .user-icon {
      \${tw\`w-10 h-10 rounded-full\`}
      transition: 0.3s all;
      \${headerDownSize && tw\`w-8 h-8\`}
    }

    @media (max-width: \${MD_SIZE}) {
      \${tw\`px-4\`}
    }
  \`;

  📁config.ts

  export const FLEX_STYLE = (justify: string, align: string, flexStyle?: string) => \`
    display:flex;
    justify-content:\${justify};
    align-items:\${align};
    flex-direction:\${flexStyle};
  \`;

  export const ELLIPSIS_STYLE = (lineHeight: number, clamp: number, height: string) => \`
    line-height: \${lineHeight};
    -webkit-line-clamp: \${clamp};
    height: \${height};
    display: -webkit-box;
    -webkit-box-orient: vertical;
    overflow: hidden;
    word-wrap: break-word;
    text-overflow: ellipsis;
  \`;

  export const GRID_STYLE = (gap: string, colums: string, row?: string) => \`
    display:grid;
    grid-template-columns:\${colums};
    grid-template-rows:\${row};
    gap:\${gap};
  \`;

  ...

```

<br/>

### 14. 데이터베이스 ER 다이어그램
- 모든 중심은 User Table로 돌아가며 하위엔티티에는 Cascade를 적용합니다. Comment와 Notice는 역정규화로 하나의 테이블을 이용하고있습니다. 1:1, 1:N, N:M 관계를 이해합니다.

<br/>

![fallinasia_erd](https://user-images.githubusercontent.com/74864925/130349640-2e721aec-def3-498c-8003-44fb1ded6b19.jpg)

<br/>

### 15. NestJS의 라이프사이클을 이해하며 적극적으로 사용했습니다.
- Middleware (ex/ session,multer ...) , Guard , Intersepter , Decorators 등을 이해합니다.

<br/>

```javascript

📁moments.controller.ts

  // UserGuards를 사용해서 로그인된 사용자인지 확인합니다.
  @UseGuards(new LoggedInGuard())
  @ApiOperation({ summary: 'Create moment post' })
  @UseInterceptors(
    // UserInterceptor의 multer를 이용해 이미지파일을 저장합니다.
    FilesInterceptor('image', 5, {
      storage: multerS3({
        s3: new AWS.S3(),
        bucket: process.env.S3_BUCKET_NAME,
        key(req, file, cb) {
          cb(
            null,
            \`original/\${Date.now()}_\${path.basename(file.originalname)}\`,
          );
        },
      }),
      limits: { fileSize: 20 * 1024 * 1024 },
    }),
  )
  @Post()
  async createPost(
    // DTO도 체계적이게 작성해줍니다.
    @Body() form: MomentCreateRequestDto,
    // Decorator를 이용해 바로 passportJS에서 user를 뽑아줍니다.
    // Decorator가 없으면 @Req() 에서 req.user로 두번 뽑아야하는 번거로움이 있습니다.
    @User() user,
    @UploadedFiles() files: Express.MulterS3.File[],
  ) {
    return await this.MomentsService.createPost(form, user.id, files);
  }

  
  📁user.decorator.ts

  export const User = createParamDecorator(
    (data: unknown, ctx: ExecutionContext) => {
      // context에서 http의 req를 불러오고 passportJS를 통해 user를 가져옵니다. 
      // user는 자주 불러오기때문에 decorator로 만들어주었습니다.
      const request = ctx.switchToHttp().getRequest();
      return request.user;
    },
  );


  📁logged-in.guard.ts

  @Injectable()
  export class LoggedInGuard implements CanActivate {
    canActivate(
      context: ExecutionContext,
    ): boolean | Promise<boolean> | Observable<boolean> {
      // context에서 http의 req를 불러오고 passportJS를 통해 isAuthenticated 가져옵니다. 
      // isAuthenticated는 boolean값이며 이 guard를 거쳐가면 인증된 유저만 구별해 controller를 실행시킬 수 있습니다.
      const request = context.switchToHttp().getRequest();
      return request.isAuthenticated();
    }
  }
  
```

<br/>

### 16. Mysql의 ngram Full-text검색과 인덱싱을 이용해 DB 검색 성능을 향상시켰습니다.
- 이전 프로젝트(Noahworld)에서 Like '%키워드%'의 풀스캔을 사용했을때보다 5~10배정도 속도를 향상시켰습니다.

<br/>

```javascript

📁Moments.ts

  // 인덱싱과 fulltext 모드를 사용합니다. parser는 띄어쓰기가 지배적이지 않은 문자인 한중일어에서 자주 사용하는 n-gram으로 채택했습니다.
  // 비단 fulltext 검색뿐만이 아니라 다양한 엔티티에 인덱싱을 지정해주었습니다.

  @Index(['content'], { fulltext: true, parser: 'ngram' })
  @IsString()
  @IsNotEmpty()
  @ApiProperty({
    example: '제가 물어볼게있습니다! 저는 태국을 여행하는..',
    description: 'content in the main post',
  })
  @Column('longtext', { name: 'content' })
  content: string;

...

  📁app.service.ts

  async getSearchPosts(searchWord: string) {
    const moments = await this.MomentsRepository.createQueryBuilder('moments')
      .leftJoinAndSelect('moments.country', 'country')
      .leftJoinAndSelect('moments.user', 'user')
      .where(\`MATCH(content) AGAINST ('\${searchWord}' IN BOOLEAN MODE)\`)
      .getMany();

    const stories = await this.StoriesRepository.createQueryBuilder('stories')
      .select(['stories.title', 'stories.thumbnail', 'stories.id'])
      .leftJoinAndSelect('stories.country', 'country')
      .leftJoinAndSelect('stories.comments', 'comments')
      .leftJoinAndSelect('stories.likedUser', 'likedUser')
      .leftJoinAndSelect('stories.user', 'user')
      .where(\`MATCH(stories.content) AGAINST ('\${searchWord}' IN BOOLEAN MODE)\`)
      .orWhere(
        \`MATCH(stories.region) AGAINST ('\${searchWord}' IN BOOLEAN MODE)\`,
      )
      .orWhere(\`MATCH(stories.title) AGAINST ('\${searchWord}' IN BOOLEAN MODE)\`)
      .getMany();

    return { searchWord, moments, stories };
  }

```

<br/>

### 17. 실시간 인기 게시글 기능을 구현했습니다.
- 자체적으로 점수를 매겨 뽑아낸 인기 게시글 4개를 프론트로 전달합니다.

<br/>

```javascript

📁stories.service.ts

  async getPopularPosts(code?: string) {
    const pointWithpostId = await this.StoriesRepository.createQueryBuilder(
      'stories',
    )
      .select([
        'stories.id',
        'stories.hit',
        'likedUser.id as user_len',
        'comments.id as comment_len',
      ])
      .leftJoinAndSelect('stories.likedUser', 'likedUser')
      .leftJoinAndSelect('stories.comments', 'comments')
      .where(code ? \`stories.code = :code\` : '1=1', { code })
      .orderBy('stories.id', 'DESC')
      .take(50)
      .getMany()
      .then((res) => {
        return res
          .map((v) => {
            // 최신 50개의 게시글을 가져오고 그중에서 점수를 매겨서 상위 4개를 가져옵니다.
            return {
              // 조회수 1회당 저는 0.001점을 부여하였고,
              // 댓글의 경우 1점을 부여하였습니다.
              // 그리고 추천의 경우 가장 높은 배점인 5점을 설정하였습니다.
              id: v.id,
              point: v.hit * 0.001 + v.comments.length + v.likedUser.length * 5,
            };
          })
          .sort((a: any, b: any) => b.point - a.point)
          .splice(0, 4);
      });
    let popularPosts = [];
    for (const i of pointWithpostId) {
      //상위 4개의 인기포스트를 각각 배열에 담아 반환합니다.
      await this.StoriesRepository.findOne({
        where: { id: i.id },
        relations: ['user', 'country', 'likedUser', 'comments'],
      }).then((res) => {
        popularPosts.push(res);
      });
    }

    return popularPosts;
 
 ```

<br/>

### 18. 조회수 중복방지 기능을 구현했습니다.
- 현재는 사이트가 조회수 어뷰징을 할만한 규모의 사이트도 아니며 되려 오버엔지니어링의 느낌을 받아 삭제했습니다. 이런 기능을 구현하고 공부를 했다는 사실에 만족합니다.

<br/>

```javascript

// 새로운 오브젝트를 생성합니다.
  // 서버를 재시작하면 오브젝트도 초기화된다는 단점이 있습니다.
  const viewObj = new Object();

  ...

  async getOnePost(storyId: number, code: string, ip: string) {
    const post = await this.StoriesRepository.findOne({
      where: {
        id: storyId,
        code,
      },
      relations: [
        'user',
        'country',
        'likedUser',
        'images',
        'comments',
        'comments.user',
        'comments.likedUser',
        'comments.subComments',
        'comments.subComments.user',
      ],
    });
    if (!post) {
      throw new NotFoundException('가져올 게시물이 없습니다.');
    }
    // client ip는 X-Forwarded-For 설정을 통해 req header 에서 가져옵니다
    // 이 프로젝트는 reverse proxy 를 쓰기때문에 nginx config와 trust proxy 설정도 추가하였습니다.
    if (post && ip !== 0) {
      if (!viewObj[storyId]) {
        // 값이없다면 빈배열을 만듭니다.
        viewObj[storyId] = [];
      }
      if (viewObj[storyId].indexOf(ip) === -1) {
        // 해당 ip가 obj에 없다면 추가하고 조회수를 올립니다.
        viewObj[storyId].push(ip);
        await this.StoriesRepository.createQueryBuilder('stories')
          .update('stories')
          .update()
          .set({
            hit: () => 'hit + 1',
          })
          .where('id = :id', { id: storyId, code })
          .where('id = :id', { id: storyId })
          .execute();
        setTimeout(() => {
          viewObj[storyId].splice(viewObj[storyId].indexOf(ip), 1);
          //10분뒤에 값을 삭제해줍니다. 즉 10분뒤에 다시 게시글을 보면 조회수가 올라갑니다.
        }, 1000*60*10);
      }
    }
    return post;
  }
  
```

<br/>

### 19. 협업을 대비해 Swagger를 이용한 API docs 와 git Branch,Trello,Slack등을 사용했습니다.
- 저는 프론트,서버,배포를 혼자서 작업했기때문에 협업을 미리 경험해 대비하는게 옳다고 생각하여 협업툴을 혼자 사용해봤습니다.

<br/>

<div align=center>

![fallinasia_apidocs](https://user-images.githubusercontent.com/74864925/130349713-1a292a03-f401-4878-ac45-4c3929aedc94.png)

![fallinasia_slack](https://user-images.githubusercontent.com/74864925/130349715-780190a1-b9b4-48d4-acba-6bc5100898f2.jpg)

![fallinasia_trello](https://user-images.githubusercontent.com/74864925/130349716-a0654450-6964-4638-b693-254652dd7aa9.jpg)
  
  </div>

<br/><br/><br/>

## 🎯 Self Interview

<br/>

> 🎤 :Redux vs SWR , React-Query

리덕스는 방대한 코드량(+반복작업)이랑 초기설정,무거움이 단점입니다. 하지만 npm trand나 Devtool의 강력함, 마지막으로 안정성을 추구하고 변화에 신중해야하는 실무에선 redux가 훨씬 압도적이며 저 또한 redux가 여러방면에서 좋다고 생각합니다. 실무에서 어떤기술을 쓰느냐에 따라가기로했으며, 이 프로젝트에서도 SWR을 주로 사용했지만 local쪽과 user부분 상태관리는 redux-toolkit을 사용해 구현했습니다.

<br/>

> 🎤 : NestJS vs Express

Express가 자유분방한 "나는 자연인이다" 느낌이라면 NestJS는 법칙과 룰이있는 "정글의법칙" 느낌이였습니다. NestJS도 Express를 기반으로 만들어졌고 거기에 더해 일관성있는 구조와 Angular와 Spring의 대략적인 흐름도 어렴풋이 익힐수있기 때문에 NestJS를 더 선호합니다. 

<br/>

> 🎤 : tailwind.CSS 어떤가요?

아주 만족하고 잘 사용하고있습니다. 허나 저의 코딩컨벤션이 html과 css는 되도록 따로 분리하는것인데 jsx의 class에 tailwind를 넣게되면 그 취지에 어긋나게됩니다. 그래서 twin.macro를 사용해 CSS in JS와 묶어서 따로 관리했습니다.

<br/>

> 🎤 : Mapbox vs Google map

이용이 간편하고 API 한도 제약이 거의 없는 Mapbox를 선호하나 빌드때 Analyzer에서 용량이 어마무시 하다는것을 발견했습니다. Tree shaking을 해보려 문의해봤지만 "우리의 라이브러리는 매우 고급지고 기능이 많기때문에 용량이 큰건 어쩔수없다" 라는 답변이 돌아왔습니다. 맞는말이며, 일단 유지보수시 용량때문에 차질이 생기면 google map으로 변경 할 생각힙니다.

<br/><br/><br/>

## 🎯 Feedback

<br/>

> 🎤 : 개발과정 중 힘들었던 부분과 피드백은?

<br/>

- 배포 후 모바일에서 antd와 emotion의 grobal style이 서로 충돌을 일으켜서 문제를 해결하는 데 애를 먹었습니다. css의 적용 우선순위와 충돌에 대해서 알게 되었습니다.

- 프론트엔드 성능 최적화 작업에 대해서 기본기가 부족했습니다. 공부 후 비동기 http 요청에 무거움을 인지해 쓸데없는 서버 요청을 줄였으며, 리플로우를 최소화, 다이나믹라우팅 (특히 맵모듈과 위지글에디터), 스크롤이벤트의 throttle , 이미지 리사이즈 및 압축 등을 사용해 최적화했습니다.

- DB를 계속 정규화해서 결국 많은 조인 연산으로 DB 성능이 감소했었습니다. Comment와 Notice는 역정규화를 완료했으나 Moments + Stories + Articles 테이블 까지도 하나의 Posts 테이블로 역정규화를 해야할지 아직 갈피를 잡지 못하고 있습니다.

- 하나의 GET 요청에 11번의 DB 접근을 하는 쿼리 (인기국가리스트요청)와 IP를 통한 중복조회수 방지기능이 서버성능에 무리를 줬었습니다. 코드는 안 쓰는 게 가장 좋은 코드라는 말이 모토이기때문에 꼭 필요한 기능인지 점검 후 제거했습니다.

- 실무에선 분업과 협업을 통해서 일하기 때문에 혼자서 디자인부터 배포까지 다한 것이 독이 될 수 있다는 점을 깨달았습니다. 저는 명확하게 프론트엔드를 지망하며 최근에는 특히 CSS를 좀 더 깊게 공부하고 있습니다.

- 위와 같은 일환으로 협업을 하지 않아 자기만의 세계에 갇힌 느낌이 듭니다. 협업툴을 혼자서 사용해보며 협업에 미리 대비했고 다른 사람의 프로젝트나 오픈소스를 분석 해보며 여러 사람의 코드를 잘 흡수할 수 있도록 공부하고 있습니다. 또한 실무에선 회사의 코딩컨벤션과 기술 스택을 잘 따르기로 다짐했습니다.

<br/><br/><br/>

## Thank you!

<br/>

> 🎤 : 구경갈래요!

#### <a href="https://fallinasia.com">Fall IN Asia 바로가기</a>
#### 테스트 계정 : test@test / 123123123

<br/>

> 🎤 : 업데이트 상황을 알려주세요

<br/>

| Date | Version | Update |
| ------ | ------ | ------ |
| 2020/08/13 | v1.0 | Final Update for first deployment through AWS |
| 2020/10/13 | v1.1 | SEO Optimization |
| 2020/11/09 | v1.2 | KOR&JPN&ENG Multilingual System |

<br/>

> 🎤 : 마지막으로 하고 싶은말은?

<br/>

피드백은 항상 저를 성장시키게 합니다.

궁금한게 있으시면 noah071610@gmail.com 으로 언제든지 편하게 연락주세요.


<br/><br/><br/>

